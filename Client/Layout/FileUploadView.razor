@using System.IO
@using System.Linq
@using System.Net.Http.Headers

<div>
    <!-- Label -->
    <label for="@Model.InputId" 
           class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">
        @Model.Label
    </label>

    <!-- File Input -->
    <InputFile 
        id="@Model.InputId"
        type="file"
        class="@GetInputClasses()"
        multiple="@Model.Multiple"
        accept="@Model.Accept"
        OnChange="@HandleFileSelection"
        disabled="@Model.IsUploading" />

    <!-- Error Message -->
    @if (!string.IsNullOrEmpty(Model.ErrorMessage))
    {
        <p class="mt-1 text-sm text-red-600 dark:text-red-500">@Model.ErrorMessage</p>
    }

    <!-- Selected Files Preview -->
    @if (Model.Files.Any())
    {
        <div class="mt-4 space-y-2">
            <h4 class="text-sm font-medium text-gray-900 dark:text-white">
                Selected Files (@Model.Files.Count)
            </h4>

            <ul class="divide-y divide-gray-200 dark:divide-gray-700">
                @foreach (var file in Model.Files)
                {
                    <li class="py-2">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <div class="flex-shrink-0">
                                    <FileIcon ContentType="@file.ContentType" />
                                </div>
                                <div>
                                    <p class="text-sm font-medium text-gray-900 dark:text-white truncate max-w-xs">
                                        @file.FileName
                                    </p>
                                    <p class="text-xs text-gray-500 dark:text-gray-400">
                                        @file.FormattedSize
                                    </p>
                                </div>
                            </div>
                            <button type="button" 
                                    @onclick="() => RemoveFile(file.Id)"
                                    class="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                            </button>
                        </div>

                        <!-- Upload Progress -->
                        @if (Model.IsUploading)
                        {
                            <div class="mt-1 w-full bg-gray-200 rounded-full h-1.5 dark:bg-gray-700">
                                <div class="bg-blue-600 h-1.5 rounded-full" style="width: @(file.Error != null ? "0%" : "100%")"></div>
                            </div>
                        }

                        @if (file.Error != null)
                        {
                            <p class="mt-1 text-xs text-red-600 dark:text-red-500">@file.Error</p>
                        }
                    </li>
                }
            </ul>
        </div>
    }

    <!-- Upload Button -->
    @if (Model.Files.Any() && !Model.IsUploading)
    {
        <div class="mt-4">
            <button type="button"
                    @onclick="UploadFiles"
                    class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 dark:bg-blue-600 dark:hover:bg-blue-700 focus:outline-none dark:focus:ring-blue-800">
                Upload @(Model.Files.Count > 1 ? "Files" : "File")
            </button>
        </div>
    }
</div>

@code {
    [Parameter] public FileUploadModel Model { get; set; } = new();

    [Inject] public HttpClient Http { get; set; } = default!;

    // Events
    [Parameter] public EventCallback<List<UploadedFile>> OnFilesSelected { get; set; }
    [Parameter] public EventCallback<List<UploadResult>> OnFilesUploaded { get; set; }

    private string GetInputClasses()
    {
        var baseClasses = "block w-full text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 dark:text-gray-400 focus:outline-none dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400";

        return Model.Size switch
        {
            "small" => $"{baseClasses} text-xs",
            "large" => $"{baseClasses} text-lg p-4",
            _ => $"{baseClasses} text-sm"
        };
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        Model.ErrorMessage = "";
        Model.Files.Clear();

        var files = e.GetMultipleFiles(maximumFileCount: Model.Multiple ? 10 : 1);

        foreach (var file in files)
        {
            var uploadedFile = new UploadedFile
            {
                FileName = file.Name,
                ContentType = file.ContentType,
                Size = file.Size,
                BrowserFile = file
            };

            var validationError = ValidateFile(uploadedFile);
            if (validationError != null)
            {
                uploadedFile.Error = validationError;
            }
            else if (IsImageFile(file.ContentType))
            {
                uploadedFile.PreviewUrl = await GenerateImagePreview(file);
            }

            Model.Files.Add(uploadedFile);
        }        
    }

    private string? ValidateFile(UploadedFile file)
    {
        if (file.Size > Model.MaxFileSizeBytes)
        {
            var maxSizeMb = Model.MaxFileSizeBytes / (1024 * 1024);
            return $"File exceeds {maxSizeMb}MB limit.";
        }

        if (Model.AllowedExtensions.Any())
        {
            var ext = Path.GetExtension(file.FileName).ToLowerInvariant();
            if (!Model.AllowedExtensions.Contains(ext))
                return $"Allowed: {string.Join(", ", Model.AllowedExtensions)}";
        }

        return null;
    }

    private bool IsImageFile(string contentType) => contentType.StartsWith("image/");

    private async Task<string> GenerateImagePreview(IBrowserFile file)
    {
        var resized = await file.RequestImageFileAsync(file.ContentType, 100, 100);
        var buffer = new byte[resized.Size];
        await resized.OpenReadStream().ReadAsync(buffer);
        return $"data:{file.ContentType};base64,{Convert.ToBase64String(buffer)}";
    }

    private void RemoveFile(string fileId)
    {
        var file = Model.Files.FirstOrDefault(f => f.Id == fileId);
        if (file != null) Model.Files.Remove(file);
    }
    List<UploadResult> successfulUploads = [];
    List<UploadedFile> failedUploads = [];
    private async Task UploadFiles()
    {
        Model.IsUploading = true;
        Model.ErrorMessage = "";

        try
        {
            foreach (var uploadedFile in Model.Files.ToList()) // ToList() to avoid mutation issues
            {
                if (uploadedFile.Error != null || uploadedFile.BrowserFile == null)
                    continue;

                try
                {
                    using var formData = new MultipartFormDataContent();
                    using var fileStream = uploadedFile.BrowserFile.OpenReadStream(Model.MaxFileSizeBytes);
                    using var fileContent = new StreamContent(fileStream);

                    // Set proper content type
                    fileContent.Headers.ContentType = new MediaTypeHeaderValue(uploadedFile.BrowserFile.ContentType);

                    formData.Add(fileContent, "file", uploadedFile.BrowserFile.Name);

                    var response = await Http.PostAsync("uploads/upload", formData);

                    if (response.IsSuccessStatusCode)
                    {
                        var result = await response.Content.ReadFromJsonAsync<UploadResultDto>();
                        successfulUploads.Add(new UploadResult(result!));
                        uploadedFile.Error = null;
                        Console.WriteLine($"Uploaded: {result?.PreviewUrl}");
                    }
                    else
                    {
                        var errorText = await response.Content.ReadAsStringAsync();
                        uploadedFile.Error = $"HTTP {response.StatusCode}: {errorText}";
                        Console.WriteLine($"Error: {uploadedFile.Error}");
                        failedUploads.Add(uploadedFile);
                    }
                }
                catch (Exception ex)
                {
                    uploadedFile.Error = $"Upload failed: {ex.Message}";
                }
            }                        

            if (successfulUploads.Any())
            {
                await OnFilesUploaded.InvokeAsync(successfulUploads);   
            }

            if (failedUploads.Any())
            {
                Model.ErrorMessage = $"Failed to upload {failedUploads.Count} file(s).";
                // Optionally clear all or only failed
                Model.Files.Clear();
                Model.Files.AddRange(failedUploads); // Keep failed ones
            }
        }
        catch (Exception ex)
        {
            Model.ErrorMessage = $"Unexpected error: {ex.Message}";
        }
        finally
        {
            Model.IsUploading = false;
            if (Model.Files.Any() && !Model.Files.Any(f => f.Error != null))
            {
                // If all files uploaded successfully, clear the list
                Model.Files.Clear();
            }                        
        }
    }    
}